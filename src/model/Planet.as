package model {		public class Planet {		public var x: Number;		public var y: Number;				public var radius: Number;		public var mass: Number;		private var bounce: Number;				public var havingAffect: Boolean = false;		public var colliding: Boolean = false;		public function Planet(x: Number, y: Number, mass: Number, bounce: Number) {			this.x = x;			this.y = y;			this.mass = mass;			this.radius = this.mass / 20;			this.bounce = bounce;		}				public function collisionDetection(target: Ball) {						this.colliding = false;						// AABB hit test			if (target.x + target.radius + this.radius > this.x				&& target.x < this.x + target.radius + this.radius				&& target.y + target.radius + this.radius > this.y				&& target.y < this.y + target.radius + this.radius) {								//var distance: Number = Math.sqrt(((target.x - this.x) * (target.x – this.x)));								var distance = Math.sqrt(((target.x - this.x) * (target.x - this.x)) + ((target.y - this.y) * (target.y - this.y)));								//var distance: Number = Math.sqrt(((target.x - this.x) * (target.x – this.x)) + ((target.y - this.y) * (target.y – this.y)));								//var dist: Number = Math.pow(this.x - target.x, 2) + Math.pow(this.y - target.y, 2);				//if (dist < (Math.pow(target.radius + this.radius, 2))) {				if (distance < target.radius + this.radius) {					this.colliding = true;										var collisionPointX: Number = ((target.x * this.radius) + (this.x * target.radius))													/ (this.radius + target.radius);					var collisionPointY: Number = ((target.y * this.radius) + (this.y * target.radius)) 													/ (this.radius + target.radius);					var angle = Math.atan2(target.y - collisionPointY, target.x - collisionPointX);					var reflectionAngle = angle - Math.PI / 2;					var targetAngle = Math.atan2(target.yVelocity, target.xVelocity);					var targetVelocity = Math.sqrt(Math.pow(target.xVelocity, 2) + Math.pow(target.yVelocity, 2));					var adjustedTargetAngle = targetAngle - reflectionAngle;					var reflectionTargetAngle = -adjustedTargetAngle;					var finalAngle = reflectionTargetAngle + reflectionAngle;										target.xVelocity = targetVelocity * this.bounce * Math.cos(finalAngle);					target.yVelocity = targetVelocity * this.bounce * Math.sin(finalAngle);				}			}						/*			var dist: Number = Math.pow(this.x - target.x, 2) + Math.pow(this.y - target.y, 2);			var angle = Math.atan2(target.y - this.y, target.x - this.x);						if (dist < Math.pow(this.radius, 2)) {				var reflectionAngle = angle - Math.PI / 2;				var targetAngle = Math.atan2(target.yVelocity, target.xVelocity);				var targetVelocity = Math.sqrt(Math.pow(target.xVelocity, 2) + Math.pow(target.yVelocity, 2));				var adjustedTargetAngle = targetAngle - reflectionAngle;				var reflectionTargetAngle = -adjustedTargetAngle;				var finalAngle = reflectionTargetAngle + reflectionAngle;								target.xVelocity = targetVelocity * this.bounce * Math.cos(finalAngle);				target.yVelocity = targetVelocity * this.bounce * Math.sin(finalAngle);								target.x = this.x + Math.cos(-angle) * (this.radius);				target.y = this.y + Math.sin(angle) * (this.radius);			}			*/		}				public function updateTarget(target: Ball): void {			var dist: Number = Math.pow(this.x - target.x, 2) + Math.pow(this.y - target.y, 2);				var affect = this.mass / dist * 4;			this.havingAffect = affect > 0.05;				if (havingAffect) {				var angle = Math.atan2(target.y - this.y, target.x - this.x);								var xDelta = Math.cos(angle) * Math.min(10, affect);				var yDelta = Math.sin(angle) * Math.min(10, affect);								target.xVelocity = target.xVelocity - xDelta;				target.yVelocity = target.yVelocity - yDelta;			}		}	}	}